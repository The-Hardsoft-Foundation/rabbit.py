# command.py

from enum import Enum

from transpile import Transpilable, Row


# represents a potential input to a command
# some commands accept only a subset of this
CommandExpr = int | float | str


# the base command class that every command inherits from
# for the parameters of most commands, they can take in expressions, which will be dealt with in the future
class Command(Transpilable):
    def __init__(self):
        pass


# some commands will be missing
# newPattern is automatically generated by the pattern transpile, so it isnt included

# TODO: add orderBin commands
# not entirely sure what they represent rn

# ends the current pattern
# note: this doesn't mean nothing can come after it, it just means it ends the pattern here
# note: ???
class EndPattern(Command):
    def __init__(self):
        pass

    def transpile(self) -> list[Row]:
        return [Row("endPattern")]


# Decides whether to continue running the current time block based on player count
class CondPlayerCount(Command):
    def __init__(self, with_1: str, with_2: str, with_3: str, with_4: str):
        if type(with_1) == str:
            assert with_1 == "true" or with_1 == "false", f"CondPlayerCount: arg[0] must be either 'true' or 'false': got {with_1}"
        else:
            raise AssertionError(f"CondPlayerCount: arg[0] must be str: got {type(with_1)}")

        if type(with_2) == str:
            assert with_2 == "true" or with_2 == "false", f"CondPlayerCount: arg[1] must be either 'true' or 'false': got {with_2}"
        else:
            raise AssertionError(f"CondPlayerCount: arg[1] must be str: got {type(with_2)}")
        
        if type(with_3) == str:
            assert with_3 == "true" or with_1 == "false", f"CondPlayerCount: arg[2] must be either 'true' or 'false': got {with_1}"
        else:
            raise AssertionError(f"CondPlayerCount: arg[2] must be str: got {type(with_3)}")
        
        if type(with_4) == str:
            assert with_4 == "true" or with_1 == "false", f"CondPlayerCount: arg[3] must be either 'true' or 'false': got {with_1}"
        else:
            raise AssertionError(f"CondPlayerCount: arg[3] must be str: got {type(with_4)}")
        
        self.with_1 = with_1
        self.with_2 = with_2
        self.with_3 = with_3
        self.with_4 = with_4

    def transpile(self) -> list[Row]:
        return [Row(["condPlayerCount", str(self.with_1), str(self.with_2), str(self.with_3), str(self.with_4)])]


# Decides whether to continue running the current time block based on the current difficulty setting
class CondDifficultyCheck(Command):
    def __init__(self, with_1: str, with_2: str, with_3: str):
        if type(with_1) == str:
            assert with_1 == "true" or with_1 == "false", f"CondDifficultyCheck: arg[0] must be either 'true' or 'false': got {with_1}"
        else:
            raise AssertionError(f"CondDifficultyCheck: arg[0] must be str: got {type(with_1)}")

        if type(with_2) == str:
            assert with_2 == "true" or with_2 == "false", f"CondDifficultyCheck: arg[1] must be either 'true' or 'false': got {with_2}"
        else:
            raise AssertionError(f"CondDifficultyCheck: arg[1] must be str: got {type(with_2)}")
        
        if type(with_3) == str:
            assert with_3 == "true" or with_1 == "false", f"CondDifficultyCheck: arg[2] must be either 'true' or 'false': got {with_1}"
        else:
            raise AssertionError(f"CondDifficultyCheck: arg[2] must be str: got {type(with_3)}")
        
        self.with_1 = with_1
        self.with_2 = with_2
        self.with_3 = with_3

    def transpile(self) -> list[Row]:
        return [Row(["condDifficultyCheck", str(self.with_1), str(self.with_2), str(self.with_3)])]


# Decides whether to continue running the current time block based on variable comparison
class CondVarCheck(Command):
    def __init__(self, left: str, comp: str, right: str):
        if type(left) == str:
            pass
        else:
            raise AssertionError(f"CondVarCheck: arg[0] must be str: got {type(left)}")

        if type(comp) == str:
            assert comp in ["==", "!=", ">", "<", ">=", "<="], f"CondPlayerCount: arg[1] is not a valid comparator: got {comp}"
        else:
            raise AssertionError(f"CondPlayerCount: arg[1] must be str: got {type(comp)}")
        
        if type(right) == str:
            pass
        else:
            raise AssertionError(f"CondVarCheck: arg[2] must be str: got {type(right)}")
        
        self.left = left
        self.comp = comp
        self.right = right

    def transpile(self) -> list[Row]:
        return [Row(["condVarCheck", str(self.left), str(self.comp), str(self.right)])]


# Decides whether to continue running the current time block based on enemy's HP (will continue if enemy HP is less than given percentage)
class CondHpThreshold(Command):
    def __init__(self, amount: CommandExpr):
        if type(amount) == int or type(amount) == float:
            assert amount >= 0.0 and amount <= 1.0, f"CondHpThreshold: arg[0] must be between 0 and 1: got {amount}"
        elif type(amount) == str:
            pass
        else:
            raise AssertionError(f"CondHpThreshold: arg[1] must be either number or str: got {type(amount)}")
        
        self.amount = amount

    def transpile(self) -> list[Row]:
        return [Row(["condHpThreshold", str(self.amount)])]
    

# Sets camera zoom for the pattern
# note: I believe 1 is the default zoom
class Zoom(Command):
    def __init__(self, amount: CommandExpr):
        if type(amount) == int or type(amount) == float:
            assert amount >= 0.0, f"Zoom: arg[0] cannot be negative: got {amount}"
        elif type(amount) == str:
            pass
        else:
            raise AssertionError(f"Zoom: arg[0] must be either number or str: got {type(amount)}")
        
        self.amount = amount

    def transpile(self) -> list[Row]:
        return [Row(["zoom", str(self.amount)])]
    

# Heals the boss
# 0 corresponds to no healing, 1 to full heal
class Heal(Command):
    def __init__(self, amount: CommandExpr):
        if type(amount) == int or type(amount) == float:
            assert amount >= 0.0 and amount <= 1.0, f"Heal: arg[0] must be between 0 and 1: got {amount}"
        elif type(amount) == str:
            pass
        else:
            raise AssertionError(f"Heal: arg[0] must be either number or str: got {type(amount)}")
        
        self.amount = amount

    def transpile(self) -> list[Row]:
        return [Row(["heal", str(self.amount)])]
    

# every enemy flag currently implemented
# can use them bitwise, so HOLMGANG | QUEEN works
class EnemyFlags(Enum):
    HOLMGANG = 1
    NO_POSITIONAL = 2
    NO_TARGET = 4
    QUEEN = 8
    PAINSHARE = 16
    HIDE_HBS = 32

# Sets special flags for the enemy.
# note: can set this using the EnemyFlags enum
# note: currently restricting this to just ints instead of expressions
#       might change this in the future
class SetFlags(Command):
    def __init__(self, flags: int):
        if type(flags) == int:
            assert flags >= 0 and flags < 64, f"SetFlags: arg[0] must be between 0 and 63: got {flags}"
        else:
            raise AssertionError(f"SetFlags: arg[0] must be either int: got {type(flags)}")
        
        self.flags = flags
        
    def transpile(self) -> list[Row]:
        return [Row(["setFlags", str(self.flags)])]     
    

# This makes changes the time/point values for the "rating bar", making it take longer to deplete and give more rewards.
# note: time_mult multiplies the "length" of the time bar, and the reward_mult gives more rewards for the same position on the bar
# note: time_mult probably cannot be 0, so that will be restricted for now
class SetResourceMult(Command):
    def __init__(self, time_mult: CommandExpr, reward_mult: CommandExpr):
        if type(time_mult) == int or type(time_mult) == float:
            assert time_mult > 0.0, f"SetResourceMult: arg[0] must be positive: got {time_mult}"
        elif type(time_mult) == str:
            pass
        else:
            raise AssertionError(f"SetResourceMult: arg[0] must be either number or str: got {type(time_mult)}")
        
        if type(reward_mult) == int or type(reward_mult) == float:
            assert reward_mult >= 0.0, f"SetResourceMult: arg[1] cannot be negative: got {reward_mult}"
        elif type(reward_mult) == str:
            pass
        else:
            raise AssertionError(f"SetResourceMult: arg[1] must be either number or str: got {type(reward_mult)}")
        
        self.time_mult = time_mult
        self.reward_mult = reward_mult

    def transpile(self) -> list[Row]:
        return [Row(["setExpMult", str(self.time_mult), str(self.reward_mult)])]
    

# Will erase the other patterns this enemy has put down, except for the pattern calling this.
class ErasePatterns(Command):
    def __init__(self):
        pass

    def transpile(self) -> list[Row]:
        return [Row("erasePatterns")]


# Moves the enemy
class Move(Command):
    def __init__(self, x: CommandExpr, y: CommandExpr, duration: CommandExpr):
        if type(x) == int or type(x) == float:
            pass
        elif type(x) == str:
            pass
        else:
            raise AssertionError(f"Move: arg[0] must be either number or str: got {type(x)}")
        
        if type(y) == int or type(y) == float:
            pass
        elif type(y) == str:
            pass
        else:
            raise AssertionError(f"Move: arg[1] must be either number or str: got {type(y)}")
        
        if type(duration) == int or type(duration) == float:
            assert duration >= 0.0, f"Move: arg[2] cannot be negative: got {duration}"
        elif type(duration) == str:
            pass
        else:
            raise AssertionError(f"Move: arg[2] must be either number or str: got {type(duration)}")
        
        self.x = x
        self.y = y
        self.duration = duration

    def transpile(self) -> list[Row]:
        return [Row(["move", str(self.x), str(self.y), str(self.duration)])]
    

# Moves the enemy, but also resets any animation they currently have running
class MoveResetAnim(Command):
    def __init__(self, x: CommandExpr, y: CommandExpr, duration: CommandExpr):
        if type(x) == int or type(x) == float:
            pass
        elif type(x) == str:
            pass
        else:
            raise AssertionError(f"MoveResetAnim: arg[0] must be either number or str: got {type(x)}")
        
        if type(y) == int or type(y) == float:
            pass
        elif type(y) == str:
            pass
        else:
            raise AssertionError(f"MoveResetAnim: arg[1] must be either number or str: got {type(y)}")
        
        if type(duration) == int or type(duration) == float:
            assert duration >= 0.0, f"MoveResetAnim: arg[2] cannot be negative: got {duration}"
        elif type(duration) == str:
            pass
        else:
            raise AssertionError(f"MovMoveResetAnime: arg[2] must be either number or str: got {type(duration)}")
        
        self.x = x
        self.y = y
        self.duration = duration

    def transpile(self) -> list[Row]:
        return [Row(["moveResetAnim", str(self.x), str(self.y), str(self.duration)])]
    

# Faces the enemy towards an x position
# note: makes the enemy face in the direction of the x position on the horizontal plane
class FacePoint(Command):
    def __init__(self, x: CommandExpr):
        if type(x) == int or type(x) == float:
            pass
        elif type(x) == str:
            pass
        else:
            raise AssertionError(f"FacePoint: arg[0] must be either number or str: got {type(x)}")
        
        self.x = x

    def transpile(self) -> list[Row]:
        return [Row(["facePoint", str(self.x)])]
    

# Faces the enemy towards a random player
class FaceRandom(Command):
    def __init__(self):
        pass

    def transpile(self) -> list[Row]:
        return [Row("faceRandom")]


# Faces a random player within a specified orderBin
# class FaceOrderBin(Command):
#     def __init__(self, order_bin: CommandExpr):
#         if type(x) == int or type(x) == float:
#             pass
#         elif type(x) == str:
#             pass
#         else:
#             raise AssertionError(f"FacePoint: arg[0] must be either number or str: got {type(x)}")
        
#         self.order_bin = order_bin

#     def transpile(self) -> list[Row]:
#         return [Row(["faceOrderBin", str(self.order_bin)])]


# note: perform an animation
# note: snap refers to how long the animation should "charge" for 
class AnimationLoop(Command):
    def __init__(self, index: int, snap: CommandExpr, duration: CommandExpr):
        if type(index) == int:
            assert index >= 0, f"AnimationLoop: arg[0] cannot be negative: got {index}"
        else:
            raise AssertionError(f"AnimationLoop: arg[0] must be int: got {type(index)}")
        
        if type(snap) == int or type(snap) == float:
            assert snap >= 0.0, f"AnimationLoop: arg[1] cannot be negative: got {snap}"
        elif type(snap) == str:
            pass
        else:
            raise AssertionError(f"AnimationLoop: arg[1] must be either number or str: got {type(snap)}")
        
        if type(duration) == int or type(duration) == float:
            assert duration >= 0.0, f"AnimationLoop: arg[2] cannot be negative: got {duration}"
        elif type(duration) == str:
            pass
        else:
            raise AssertionError(f"AnimationLoop: arg[2] must be either number or str: got {type(duration)}")
        
        self.index = index
        self.snap = snap
        self.duration = duration

    def transpile(self) -> list[Row]:
        return [Row(["animation", str(self.index), str(self.snap), str(self.duration)])]
    

# This is for certain animations that are meant to play out once without looping (like Avy's leaping animation)
# note: snap refers to how long the animation should "charge" for 
class AnimationNoLoop(Command):
    def __init__(self, index: int, snap: CommandExpr, duration: CommandExpr):
        if type(index) == int:
            assert index >= 0, f"AnimationNoLoop: arg[0] cannot be negative: got {index}"
        else:
            raise AssertionError(f"AnimationNoLoop: arg[0] must be int: got {type(index)}")
        
        if type(snap) == int or type(snap) == float:
            assert snap >= 0.0, f"AnimationNoLoop: arg[1] cannot be negative: got {snap}"
        elif type(snap) == str:
            pass
        else:
            raise AssertionError(f"AnimationNoLoop: arg[1] must be either number or str: got {type(snap)}")
        
        if type(duration) == int or type(duration) == float:
            assert duration >= 0.0, f"AnimationNoLoop: arg[2] cannot be negative: got {duration}"
        elif type(duration) == str:
            pass
        else:
            raise AssertionError(f"AnimationNoLoop: arg[2] must be either number or str: got {type(duration)}")
        
        self.index = index
        self.snap = snap
        self.duration = duration

    def transpile(self) -> list[Row]:
        return [Row(["animationNoLoop", str(self.index), str(self.snap), str(self.duration)])]
    


'''
Enemy transforms, using another animation.

The default "draw scale" for enemies is 0.5; but some enemies use a larger one in the base game:

Ranalie phase 2:  drawScale = 1
Merran phase 2: drawScale = 0.7
Shira phase 2: drawScale = 0.6

The "focus scale" is the size of player target reticles around the enemy.  The default is 1, but for larger enemies you might need to make them larger.

The "standing frame rate" is the idle framerate of the new animation.  Most animations in the game have a framerate of 4, but the larger animations (boss phase 2s + Karsi's transformed form) have a framerate of 6.
'''
class Transform(Command):
    def __init__(self, animation_key: str, new_radius: CommandExpr, new_draw: CommandExpr, new_focus: CommandExpr, idle_framerate: int):
        if type(animation_key) == str:
            assert animation_key >= 0, f"Transform: arg[0] cannot be negative: got {animation_key}"
        else:
            raise AssertionError(f"Transform: arg[0] must be int: got {type(animation_key)}")
        
        if type(new_radius) == int or type(new_radius) == float:
            assert new_radius >= 0.0, f"Transform: arg[1] cannot be negative: got {new_radius}"
        elif type(new_radius) == str:
            pass
        else:
            raise AssertionError(f"Transform: arg[1] must be either number or str: got {type(new_radius)}")
        
        if type(new_draw) == int or type(new_draw) == float:
            assert new_draw >= 0.0, f"Transform: arg[2] cannot be negative: got {new_draw}"
        elif type(new_draw) == str:
            pass
        else:
            raise AssertionError(f"Transform: arg[2] must be either number or str: got {type(new_draw)}")
        
        if type(new_focus) == int or type(new_focus) == float:
            assert new_focus >= 0.0, f"Transform: arg[3] cannot be negative: got {new_focus}"
        elif type(new_focus) == str:
            pass
        else:
            raise AssertionError(f"Transform: arg[3] must be either number or str: got {type(new_focus)}")

        if type(idle_framerate) == int:
            assert idle_framerate >= 0, f"Transform: arg[4] cannot be negative: got {idle_framerate}"
        else:
            raise AssertionError(f"Transform: arg[4] must be int: got {type(idle_framerate)}")
        
        self.animation_key = animation_key
        self.new_radius = new_radius
        self.new_draw = new_draw
        self.new_focus = new_focus
        self.idle_framerate = idle_framerate

    def transpile(self) -> list[Row]:
        return [Row(["transform", str(self.animation_key), str(self.new_radius), str(self.new_draw), str(self.new_focus), str(self.idle_framerate)])]
    

# Same as "transform", but transformation effect is very quick (like Karsi, Xin or Ran)
class TransformSmall(Command):
    def __init__(self, animation_key: str, new_radius: CommandExpr, new_draw: CommandExpr, new_focus: CommandExpr, idle_framerate: int):
        if type(animation_key) == str:
            assert animation_key >= 0, f"TransformSmall: arg[0] cannot be negative: got {animation_key}"
        else:
            raise AssertionError(f"TransformSmall: arg[0] must be int: got {type(animation_key)}")
        
        if type(new_radius) == int or type(new_radius) == float:
            assert new_radius >= 0.0, f"TransformSmall: arg[1] cannot be negative: got {new_radius}"
        elif type(new_radius) == str:
            pass
        else:
            raise AssertionError(f"TransformSmall: arg[1] must be either number or str: got {type(new_radius)}")
        
        if type(new_draw) == int or type(new_draw) == float:
            assert new_draw >= 0.0, f"TransformSmall: arg[2] cannot be negative: got {new_draw}"
        elif type(new_draw) == str:
            pass
        else:
            raise AssertionError(f"TransformSmall: arg[2] must be either number or str: got {type(new_draw)}")
        
        if type(new_focus) == int or type(new_focus) == float:
            assert new_focus >= 0.0, f"TransformSmall: arg[3] cannot be negative: got {new_focus}"
        elif type(new_focus) == str:
            pass
        else:
            raise AssertionError(f"TransformSmall: arg[3] must be either number or str: got {type(new_focus)}")

        if type(idle_framerate) == int:
            assert idle_framerate >= 0, f"TransformSmall: arg[4] cannot be negative: got {idle_framerate}"
        else:
            raise AssertionError(f"TransformSmall: arg[4] must be int: got {type(idle_framerate)}")
        
        self.animation_key = animation_key
        self.new_radius = new_radius
        self.new_draw = new_draw
        self.new_focus = new_focus
        self.idle_framerate = idle_framerate

    def transpile(self) -> list[Row]:
        return [Row(["transformSmall", str(self.animation_key), str(self.new_radius), str(self.new_draw), str(self.new_focus), str(self.idle_framerate)])]
    

# You can have anywhere from 1-3 string keys.
# If the string key exists in a StringSheet, you can have a translated string sent to other players
# If the string key doesn't exist, it will just display whatever string is written (so if you don't want to translate your mod, you can just write your dialog in
class Dialog(Command):
    def __init__(self, duration: CommandExpr, *stringKeys: list[str]):
        if type(duration) == int or type(duration) == float:
            assert duration >= 0.0, f"Dialog: arg[0] cannot be negative: got {duration}"
        elif type(duration) == str:
            pass
        else:
            raise AssertionError(f"Dialog: arg[0] must be either number or str: got {type(duration)}")

        assert len(stringKeys) >= 1 and len(stringKeys) <= 3, f"Dialog: len(arg) must be between 2 and 4: got {len(stringKeys)}"

        for i in range(3):
            assert type(stringKeys[i]) == str, f"Dialog: arg[{i + 1}] must be str: got {type(stringKeys[i])}"
        
        self.duration = duration
        self.stringKeys = stringKeys

    def transpile(self) -> list[Row]:
        row = Row(["dialog", str(self.duration)])
        row.extend(self.stringKeys)
        return [row]
    

# orderBin stuff goes here

# Will sort players evenly into four groups, orderBin0, orderBin1, orderBin2, and orderBin3.
# Players are sorted at random, and unlike orderBinChaos, two players will not be in the same group.
class OrderBinFourGroups(Command):
    def __init__(self):
        pass

    def transpile(self) -> list[Row]:
        return [Row("orderBinFourGroups")]
    

# Syncs seeds between patterns.
class SyncRandomSeed(Command):
    def __init__(self):
        pass

    def transpile(self) -> list[Row]:
        return [Row("syncRandomSeed")]


# Saves a variable for future use within this pattern
class SetVar(Command):
    def __init__(self, key: str, value: CommandExpr):
        if type(key) == str:
            pass
        else:
            raise AssertionError(f"SetVar: arg[0] must be str: got {type(key)}")

        if type(value) == int or type(value) == float:
            pass
        elif type(value) == str:
            pass
        else:
            raise AssertionError(f"SetVar: arg[0] must be either number or str: got {type(value)}")
        
        self.key = key
        self.value = value

    def transpile(self) -> list[Row]:
        return [Row(["setVar", str(self.key), str(self.value)])]
    

# Will save either true or false at random to a variable for future use within this pattern.
# note: not entirely sure what the second value is, might be whether or not to flip it?
#       if true, should call it inverse
class SetCoinflip(Command):
    def __init__(self, key: str, heads: str):
        if type(key) == str:
            pass
        else:
            raise AssertionError(f"SetCoinflip: arg[0] must be str: got {type(key)}")

        if type(heads) == str:
            assert heads == "true" or heads == "false", f"SetCoinflip: arg[1] must be either 'true' or 'false': got {type(key)}"
        else:
            raise AssertionError(f"SetCoinflip: arg[1] must be str: got {type(key)}")
        
        self.key = key
        self.heads = heads

    def transpile(self) -> list[Row]:
        return [Row(["setCoinFlip", str(self.key), str(self.heads)])]
    

# Will save one of the possibilities at random to a variable for future use within this pattern.
class SetDiceRoll(Command):
    def __init__(self, key: str, *possibilities: list[CommandExpr]):
        if type(key) == str:
            pass
        else:
            raise AssertionError(f"SetDiceRoll: arg[0] must be str: got {type(key)}")

        assert len(possibilities) >= 1, f"SetDiceRoll: len(arg) must at least 2: got {len(possibilities)}"

        for i in range(3):
            assert type(possibilities[i]) == int | type(possibilities[i]) == float | type(possibilities[i]) == str, f"SetDiceRoll: arg[{i + 1}] must be number or str: got {type(possibilities[i])}"

        self.key = key
        self.possibilities = possibilities

    def transpile(self) -> list[Row]:
        row = Row(["setDiceRoll", str(self.key)])
        row.extend(self.possibilities)
        return [row]
    

# Resets the "pattVar" list
# note: this will happen automatically sometimes, but can also be called manually
class PattVarReset(Command):
    def __init__(self):
        pass

    def transpile(self) -> list[Row]:
        return [Row("pattVarReset")]
    

# Adds any number of key-value pairs to the pattVar list.
# key-value pairs are separated with ";".
class PattVars(Command):
    def __init__(self, *kv_pairs: list[str]):
        assert len(kv_pairs) >= 1, f"PattVars: len(arg) must at least 1: got {len(kv_pairs)}"

        for i, kv in enumerate(kv_pairs):
            assert type(kv) == str, f"PattVars: arg[{i}] must be str: got {type(kv)}"
            assert kv.count(";") == 1, f"PattVars: arg[{i}] must contain exactly 1 ';': got {kv}"

        self.kv_pairs = kv_pairs

    def transpile(self) -> list[Row]:
        row = Row(["pattVars"])
        row.extend(self.kv_pairs)
        return [row]
    

# Adds positional key-value pairs, as well as the number of positional key-value pairs, to the pattVar list.
# Separate "x" and "y" with a ";".
class PattPosition(Command):
    def __init__(self, *xy_pairs: list[str]):
        assert len(xy_pairs) >= 1, f"PattPosition: len(arg) must at least 1: got {len(xy_pairs)}"

        for i, xy in enumerate(xy_pairs):
            assert type(xy) == str, f"PattPosition: arg[{i}] must be str: got {type(xy)}"
            assert xy.count(";") == 1, f"PattPosition: arg[{i}] must contain exactly 1 ';': got {xy}"

        self.xy_pairs = xy_pairs

    def transpile(self) -> list[Row]:
        row = Row(["pattPosition"])
        row.extend(self.xy_pairs)
        return [row]
    

# Similar to pattPosition, but sets a single position to the current position of the enemy using this attack.
class PattPositionEnemy(Command):
    def __init__(self):
        pass

    def transpile(self) -> list[Row]:
        return [Row("pattPositionEnemy")]
    

# order bin stuff


# Adds a new pattern to the battle.
class AddPatt(Command):
    def __init__(self, key: str):
        if type(key) == str:
            pass
        else:
            raise AssertionError(f"AddPatt: arg[0] must be str: got {type(key)}")
        
        self.key = key

    def transpile(self) -> list[Row]:
        return [Row(["pattAdd", str(self.key)])]
    

# Adds a new pattern to the battle, and also sets and "x" and "y" pattVar for it.
class PattAddPos(Command):
    def __init__(self, key: str, x: CommandExpr, y: CommandExpr):
        if type(key) == str:
            pass
        else:
            raise AssertionError(f"PattAddPos: arg[0] must be str: got {type(key)}")

        if type(x) == int or type(x) == float:
            pass
        elif type(x) == str:
            pass
        else:
            raise AssertionError(f"PattAddPos: arg[1] must be either number or str: got {type(x)}")
        
        if type(y) == int or type(y) == float:
            pass
        elif type(y) == str:
            pass
        else:
            raise AssertionError(f"PattAddPos: arg[2] must be either number or str: got {type(y)}")
        
        self.key = key
        self.x = x
        self.y = y
        
    def transpile(self) -> list[Row]:
        return [Row(["pattAddPos", str(self.key), str(self.x), str(self.y)])]
    







# test = Mod()
# p = Pattern()
# tb = TimeBlock(time)
# tb.add(Zoom(10))
# tb.add(Move(10, 10, 500))
# tb.add(SetVars())
# p.add(tb)


# test.transpile("output_folder")


# tb.add(Zoom("(bf_MinX + bf_MinY) * 2"))